name: Ping and Parse API

on:
  schedule:
    - cron: '0 * * * *' # Runs every hour
  workflow_dispatch:

jobs:
  ping_and_notify:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Send POST request
        id: send_request
        run: |
          API_URL="https://anc.ca.apm.activecommunities.com/ottawa/rest/activities/list?locale=en-US"
          
          # Dynamically get today's date
          TODAY=$(date +"%Y-%m-%d")
          
          # Use a heredoc to safely store the complex JSON payload
          POST_DATA=$(cat <<EOF
          {
            "activity_search_pattern": {
              "skills": [],
              "time_after_str": "",
              "days_of_week": "",
              "activity_select_param": 0,
              "center_ids": ["327"],
              "time_before_str": "",
              "open_spots": null,
              "activity_id": null,
              "activity_category_ids": [],
              "date_before": "",
              "min_age": null,
              "date_after": "$TODAY",
              "activity_type_ids": [],
              "site_ids": [],
              "for_map": false,
              "geographic_area_ids": [],
              "season_ids": [],
              "activity_department_ids": [],
              "activity_other_category_ids": [],
              "child_season_ids": [],
              "activity_keyword": "Swim Colours 5 â€“ Purple (low ratio)",
              "instructor_ids": [],
              "max_age": null,
              "custom_price_from": "",
              "custom_price_to": ""
            },
            "activity_transfer_pattern": {}
          }
          EOF
          )
          
          # Send request: Output body to api_response.json and capture only the HTTP status code
          HTTP_STATUS=$(curl -s -o api_response.json -w "%{http_code}" -X POST -H "Content-Type: application/json" -d "$POST_DATA" "$API_URL")
          
          # Save ONLY the HTTP Status to environment variables
          echo "HTTP_STATUS=$HTTP_STATUS" >> "$GITHUB_ENV"

      - name: Parse response and output stats
        id: parse_response
        run: |
          # 1. Check if the API call was successful
          if [ "$HTTP_STATUS" -ne 200 ]; then
            echo "âŒ Error: API returned HTTP $HTTP_STATUS"
            cat api_response.json
            exit 1
          fi

          # 2. Calculate statistics strictly and safely
          # Using "// []" ensures that if activity_items is missing, jq treats it as an empty array instead of throwing an error
          TOTAL_CLASSES=$(jq -r '.body.activity_items // [] | length' api_response.json)
          
          # Calculate how many have openings (capacity > enrolled)
          OPEN_CLASSES=$(jq -r '[.body.activity_items // [] | .[] | select((.total_open // 0) > (.already_enrolled // 0))] | length' api_response.json)
          
          # Fallbacks to 0 in bash just in case
          TOTAL_CLASSES=${TOTAL_CLASSES:-0}
          OPEN_CLASSES=${OPEN_CLASSES:-0}
          
          # Calculate Full Classes directly via bash math
          FULL_CLASSES=$((TOTAL_CLASSES - OPEN_CLASSES))

          # 3. Print the statistics table to the GitHub Actions Console
          echo "ðŸ“Š API Response Statistics:"
          echo "-----------------------------------"
          echo "HTTP Response Code    : $HTTP_STATUS"
          echo "Total Classes Found   : $TOTAL_CLASSES"
          echo "Classes Full          : $FULL_CLASSES"
          echo "Classes with Openings : $OPEN_CLASSES"
          echo "-----------------------------------"
          
          if [ "$OPEN_CLASSES" -eq 0 ] && [ "$TOTAL_CLASSES" -gt 0 ]; then
            echo "All classes are currently full. Ending action without sending a notification."
          elif [ "$TOTAL_CLASSES" -eq 0 ]; then
            echo "No classes matched the search criteria. Ending action."
          fi
          
          # Output to next step
          echo "open_classes=$OPEN_CLASSES" >> "$GITHUB_OUTPUT"

      - name: Parse and send messages for available activities
        if: steps.parse_response.outputs.open_classes > 0
        run: |
          # Loop strictly through items where total_open (capacity) > already_enrolled
          jq -c '.body.activity_items // [] | .[] | select((.total_open // 0) > (.already_enrolled // 0))' api_response.json | while read -r i; do
            NAME=$(echo "$i" | jq -r '.name')
            DOW=$(echo "$i" | jq -r '.days_of_week')
            DATES=$(echo "$i" | jq -r '.date_range')
            TIME=$(echo "$i" | jq -r '.time_range')
            DETAIL_URL=$(echo "$i" | jq -r '.detail_url')
            
            # Calculate exactly how many spots are left (Capacity - Enrolled)
            SPOTS_LEFT=$(echo "$i" | jq -r '(.total_open // 0) - (.already_enrolled // 0)')
            
            # Message formatted for WhatsApp readability
            MESSAGE=$(printf "*Class:* %s\n*Days:* %s\n*Dates:* %s\n*Time:* %s\n*Spots Available:* %s\n*Link:* %s" \
              "$NAME" "$DOW" "$DATES" "$TIME" "$SPOTS_LEFT" "$DETAIL_URL")

            # Echo the message to the console for debugging
            echo -e "Sending message:\n$MESSAGE\n---"

            # URL encode the payload
            ENCODED_MESSAGE=$(echo "$MESSAGE" | jq -sRr @uri)

            # Fire the CallMeBot API Call
            curl -s -X GET "https://api.callmebot.com/whatsapp.php?phone=${{ secrets.WHATSAPP_PHONE_NUMBER_NOTIFY }}&text=${ENCODED_MESSAGE}&apikey=${{ secrets.CALLMEBOT_APIKEY }}"
          done
