name: Ping and Parse API

on:
  schedule:
    - cron: '0 * * * *' # Runs every hour
  workflow_dispatch:

jobs:
  ping_and_notify:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Send POST request
        id: send_request
        run: |
          API_URL="https://anc.ca.apm.activecommunities.com/ottawa/rest/activities/list?locale=en-US"
          
          # Dynamically get today's date
          TODAY=$(date +"%Y-%m-%d")
          
          # Use a heredoc to safely store the complex JSON payload
          POST_DATA=$(cat <<EOF
          {
            "activity_search_pattern": {
              "skills": [],
              "time_after_str": "",
              "days_of_week": "",
              "activity_select_param": 0,
              "center_ids": ["327"],
              "time_before_str": "",
              "open_spots": null,
              "activity_id": null,
              "activity_category_ids": [],
              "date_before": "",
              "min_age": null,
              "date_after": "$TODAY",
              "activity_type_ids": [],
              "site_ids": [],
              "for_map": false,
              "geographic_area_ids": [],
              "season_ids": [],
              "activity_department_ids": [],
              "activity_other_category_ids": [],
              "child_season_ids": [],
              "activity_keyword": "Swim Colours 5 â€“ Purple (low ratio)",
              "instructor_ids": [],
              "max_age": null,
              "custom_price_from": "",
              "custom_price_to": ""
            },
            "activity_transfer_pattern": {}
          }
          EOF
          )
          
          # Send request: Output body to api_response.json and capture only the HTTP status code
          HTTP_STATUS=$(curl -s -o api_response.json -w "%{http_code}" -X POST -H "Content-Type: application/json" -d "$POST_DATA" "$API_URL")
          
          # Save ONLY the HTTP Status to environment variables
          echo "HTTP_STATUS=$HTTP_STATUS" >> "$GITHUB_ENV"

      - name: Parse response and output stats
        id: parse_response
        run: |
          # 1. Check if the API call was successful
          if [ "$HTTP_STATUS" -ne 200 ]; then
            echo "âŒ Error: API returned HTTP $HTTP_STATUS"
            cat api_response.json
            exit 1
          fi

          # 2. Calculate statistics safely using jq (reading directly from the JSON file)
          TOTAL_ENTRIES=$(jq '[.body.activity_items[]?] | length' api_response.json)
          AVAILABLE_SPOTS=$(jq '[.body.activity_items[]? | select((.total_open // 0) > 0)] | length' api_response.json)
          
          # Fallbacks just in case jq returns empty strings
          TOTAL_ENTRIES=${TOTAL_ENTRIES:-0}
          AVAILABLE_SPOTS=${AVAILABLE_SPOTS:-0}

          # 3. Print the statistics table to the GitHub Actions Console
          echo "ðŸ“Š API Response Statistics:"
          echo "-----------------------------------"
          echo "HTTP Response Code    : $HTTP_STATUS"
          echo "Total Entries Returned: $TOTAL_ENTRIES"
          echo "Entries with Openings : $AVAILABLE_SPOTS"
          echo "-----------------------------------"
          
          if [ "$AVAILABLE_SPOTS" -eq 0 ]; then
            echo "No open spots available. Ending action without sending a notification."
          fi
          
          # Output to next step
          echo "available_spots=$AVAILABLE_SPOTS" >> "$GITHUB_OUTPUT"

      - name: Parse and send messages for available activities
        if: steps.parse_response.outputs.available_spots > 0
        run: |
          # Loop strictly through items where total_open > 0 (reading directly from the JSON file)
          jq -c '.body.activity_items[]? | select((.total_open // 0) > 0)' api_response.json | while read -r i; do
            NAME=$(echo "$i" | jq -r '.name')
            DOW=$(echo "$i" | jq -r '.days_of_week')
            DATES=$(echo "$i" | jq -r '.date_range')
            TIME=$(echo "$i" | jq -r '.time_range')
            OPEN_SPOTS=$(echo "$i" | jq -r '.total_open')
            DETAIL_URL=$(echo "$i" | jq -r '.detail_url')
            
            # Message formatted for WhatsApp readability
            MESSAGE=$(printf "*Class:* %s\n*Days:* %s\n*Dates:* %s\n*Time:* %s\n*Spots Available:* %s\n*Link:* %s" \
              "$NAME" "$DOW" "$DATES" "$TIME" "$OPEN_SPOTS" "$DETAIL_URL")

            # Echo the message to the console for debugging
            echo -e "Sending message:\n$MESSAGE\n---"

            # URL encode the payload
            ENCODED_MESSAGE=$(echo "$MESSAGE" | jq -sRr @uri)

            # Fire the CallMeBot API Call
            curl -s -X GET "https://api.callmebot.com/whatsapp.php?phone=${{ secrets.WHATSAPP_PHONE_NUMBER_NOTIFY }}&text=${ENCODED_MESSAGE}&apikey=${{ secrets.CALLMEBOT_APIKEY }}"
          done
